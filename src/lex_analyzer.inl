// Lexegen autogenerated analyzer file - do not edit!

static int symb2meta[256] = {
    0, 1, 1, 1, 1, 1, 1, 1, 1, 2, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 4, 5, 1, 1, 1,
    6, 1, 1, 7, 8, 1, 8, 9, 10, 11, 12, 12, 12, 12, 12, 12, 12, 12, 12, 1, 1, 1, 1, 1, 1, 1, 13, 13, 13, 13, 14, 13, 15,
    15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 16, 15, 15, 1, 17, 1, 1, 15, 1, 13, 13, 13, 13, 14,
    13, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 16, 15, 15, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1
};

static int def[50] = {
    -1, 0, -1, 1, 3, -1, 3, 3, 3, 3, 4, 10, 3, -1, 13, 13, 13, 14, 14, -1, 8, 8, -1, 20, -1, 7, -1, 24, 6, 6, 28, 5, -1,
    28, 24, 20, -1, -1, -1, 38, -1, 31, 36, -1, 43, 44, -1, 46, 37, 48
};

static int base[50] = {
    0, 17, 20, 35, 40, 44, 57, 73, 84, 13, 101, 36, 33, 118, 135, 34, 150, 38, 147, 49, 164, 179, 49, 177, 184, 201, 66,
    218, 235, 186, 249, 263, 49, 49, 49, 49, 42, 148, 245, 33, 270, 51, 37, 148, 47, 56, 276, 56, 290, 297
};

static int next[315] = {
    2, 32, 5, 5, 33, 34, 35, 32, 32, 36, 37, 38, 39, 40, 40, 40, 40, 41, 3, 4, 13, 6, 7, 8, 3, 3, 3, 9, 3, 3, 3, 3, 3,
    3, 10, -1, 3, 3, -1, 3, 3, 3, 4, 5, 3, 3, 5, 5, 19, -1, 3, 43, 12, 42, 42, -1, 3, 11, 6, 6, 28, 31, 6, 6, 6, 6, 6,
    6, 6, 6, 6, 6, 6, 6, 29, 7, 24, 26, 26, 26, 26, 26, 26, 3, 3, 8, 8, 20, 8, 8, 25, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 21,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 13, 13, 14, 13, 13, 13, 15, 13, 13, 13, 13, 13, 13, 13, 13, 13,
    16, 14, 14, 14, 14, 14, 14, 17, 14, 14, 14, 14, 14, 14, 14, 14, 14, 18, 13, 14, 14, 44, 13, 48, 45, 45, 13, 13, 13,
    14, 20, 20, 13, 20, 20, 22, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 23, 8, 20, 8, 8, 24, 24, 8, 6, 6, 8, 8, 8, 20,
    8, 8, 26, 26, 26, 26, 27, 7, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
    24, 24, 24, 24, 24, 24, 24, 28, 28, 28, 22, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 30, 28, 42, 28, 39, 39,
    28, 43, 28, 46, 28, 28, 5, 28, 28, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 40, 40, 40, 40, 40, 40, 47, 47, 47, 47,
    48, 48, -1, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 49, 48, 48, 48, 48, 48, 48, 48
};

static int check[315] = {
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 9, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 12, 3,
    3, 3, 3, 3, 4, 4, 15, 3, 5, 5, 17, 39, 12, 42, 3, 36, 36, 44, 4, 4, 6, 6, 6, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
    6, 7, 7, 26, 26, 26, 26, 26, 26, 7, 7, 8, 8, 8, 8, 8, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 10, 10, 10, 10, 10, 10,
    10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 14,
    14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 16, 18, 37, 43, 16, 37, 43, 43, 16, 16, 16, 18, 20,
    20, 16, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 21, 23, 21, 21, 24, 24, 21, 29, 29, 21, 21, 21, 23,
    21, 21, 24, 24, 24, 24, 24, 25, 29, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 27, 27, 27, 27, 27,
    27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
    30, 38, 30, 38, 38, 30, 38, 30, 38, 30, 30, 31, 30, 30, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 40,
    40, 40, 40, 40, 40, 46, 46, 46, 46, 48, 48, 46, 48, 48, 48, 48, 48, 48, 49, 48, 48, 48, 48, 48, 48, 48, 49, 49, 49,
    49, 49, 49, 49
};

static int accept[50] = {
    0, 2, 18, 2, 2, 16, 2, 2, 2, 2, 20, 0, 0, 2, 0, 2, 0, 0, 0, 4, 0, 0, 8, 0, 0, 0, 6, 0, 0, 0, 0, 0, 20, 20, 20, 20,
    20, 20, 12, 12, 10, 20, 14, 0, 0, 14, 0, 12, 4, 0
};

static int lls_idx[51] = {
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
};

static int lls_list[1] = { 0 };

static int lex(CtxData& ctx, std::vector<int>& state_stack) {
    enum { kTrailContFlag = 1, kFlagCount = 1 };
    char symb = '\0';
    int state = state_stack.back();
    do {  // Fill buffers till transition is impossible
        if (ctx.in_next == ctx.in_boundary) {
            if (ctx.in_next == ctx.in_last) { break; }
            return -1;
        }
        symb = *ctx.in_next;
        int meta = symb2meta[static_cast<unsigned char>(symb)];
        if (meta < 0) { break; }
        do {
            int l = base[state] + meta;
            if (check[l] == state) {
                state = next[l];
                break;
            }
            state = def[state];
        } while (state >= 0);
        if (state < 0) { break; }
        ++ctx.in_next, *ctx.out_last++ = symb;
        state_stack.push_back(state);
    } while (symb != 0);
    while (ctx.out_last != ctx.out_first) {  // Unroll downto last accepting state
        int n_pat = accept[state_stack.back()];
        if (n_pat > 0) {
            bool has_trailling_context = n_pat & kTrailContFlag;
            n_pat >>= kFlagCount;
            if (has_trailling_context) {
                do {
                    state = state_stack.back();
                    for (int i = lls_idx[state]; i < lls_idx[state + 1]; ++i) {
                        if (lls_list[i] == n_pat) {
                            ptrdiff_t n_remove = ctx.out_last - ctx.out_first;
                            state_stack.erase(state_stack.end() - n_remove, state_stack.end());
                            return n_pat;
                        }
                    }
                    *(--ctx.in_next) = *(--ctx.out_last);
                    state_stack.pop_back();
                } while (ctx.out_last != ctx.out_first);
            }
            ptrdiff_t n_remove = ctx.out_last - ctx.out_first;
            state_stack.erase(state_stack.end() - n_remove, state_stack.end());
            return n_pat;
        }
        *(--ctx.in_next) = *(--ctx.out_last);
        state_stack.pop_back();
    }
    if (ctx.in_next == ctx.in_last) { return -1; }
    *ctx.out_last++ = *ctx.in_next++;  // Accept at least one symbol as default pattern
    return predef_pat_default;
}
